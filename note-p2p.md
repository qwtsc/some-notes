# P2P techniques for decentralized Application学习笔记
## preface
1. p2p的优势在于去中心化与对称性（自己既是服务端又是客户端）带来的自我扩展性（self-scalability），自组织性（self-organization），容错性（fault-tolerance）。
2. p2p比较难实现针对关键词的推荐搜索，top-k可以避免搜索过多无用的信息来阻塞p2p的网络，这本书主要关注于p2p在top-k，CDN与推荐系统上的应用。

## 第一章 P2P Overlays ,Query Routing, and Gossiping
### P2P与传统的分布式数据库系统的区别
1. P2P网络中的节点非常动态，可以在任意时间自由进入和离开网络中，而分布式数据库系统中的节点则是需要被控制的情况下才能进入和离开。
2. p2p没有事先定义的全局性的schema来描述需要被节点分享的数据。
3. p2p系统中对请求的响应是不完全的，因为有一些节点在请求发出时不在网络中，对于非常大的p2p网络，把请求转发给所有节点是非常没有效率的。
4. p2p系统中没有集中式的目录来决定请求的内容位于哪些节点中，与之对比的是，这样的集中式目录对于分布式数据库系统是非常必要的。

### P2P overlays
+ p2p的虚拟网络的架构有三种，无结构式，结构式和super-peer式。

1. 无结构式
  * 在一个无结构的p2p虚拟网络中，网络的拓扑结构处于无序状态，请求的路由策略就是限制请求源的跳跃距离（hop distance）。
  * 在这种情况下，请求的形式没有限制，容错率非常高，每一个节点可以自主地决定储存哪些数据。
  * 但是这种架构，请求路由没有效率（网络的负载很高，一定程度上牺牲了可扩展性），同时请求地结果很有可能不完全（一些拥有相关数据的节点超过了规定的hop distance）。
2. 结构式
  * 结构式的虚拟网络主要在于能够**有效率**地进行请求的路由，主要代表是分布式hash表（DHT），hash表通过通过建立数据的hash值和节点p的映射，可以让寻找节点p的时间复杂度控制在O(logn)，n是网络中节点的个数。DHT如同普通的hash表一样提供get和put方法。
  * 采用这种架构的虚拟网络的节点的自由度受到了限制，因为特定数据的hash值映射得到的节点p是需要被用来提供该特定数据的。
3. super-peer
  * super-peer是对纯p2p架构（以上所述的两种）和cs架构（client-server架构）的混合，在这种虚拟网络结构中有一些超级节点（被称作super peer）需要进行例如索引，请求处理，权限控制以及元数据管理的工作，（如果只有一个超级节点，那么这种架构就会退化成传统的cs架构），这些超级节点之间可以使用p2p来进行连接和通信，所以可以实现一些数据的分区和重复，当然这些特殊节点是通过他们的带宽和处理能力来动态地选举产生以及被替换的。
  * 在响应请求时，超级节点可以从自身的索引（询问自身节点群？）来直接响应或者询问相邻的超级节点来响应，这种架构的主要优点是服务的高效率和高质量，通过索引来获取数据的响应的时间远低于无规则的路由响应时间，超级节点由于是动态选举出来的，他需要负载压力时大于自身节点群中的普通节点的，但是不同于cs架构，超级节点也是可以利用其他普通节点的cpu/储存/贷款等能力来提供服务，而不是全部自身来响应。这种架构下普通节点的自治能力需要被限制，不能随意跨越超级节点。

p2p虚拟网络的几个要求
1. *自治性* 可以在任何时间加入和离开系统以及可以被任何人连接
2. *请求的可表达性* 对于文件类的p2p关键字搜索就足够了，但是对于一些结构化数据，需要使用一些类似于sql的请求语言。
3. *请求的有效处理* 高效利用p2p的网络资源可以达到较低的延时。
4. *服务质量* 指的是用户接受到的p2p效率，包括请求结果的完全性以及响应时间
5. *容错性* 服务需要保证在一些节点崩溃的情况下仍然正常工作。

### Query Routing请求路由算法概述
#### 无结构虚拟网络请求路由算法
1. BFS搜索
  * 在特定的ttl下，转发请求，每转发一次ttl减少1，直至ttl降低为0，这样就会使得在hop distance小于ttl的节点收到并处理请求。
  * 对BFS搜索进行一定的修改，例如随机地搜索一部分邻居节点（而不是像bfs一样全局搜）或者是维护一个请求相似性统计数据，优先把请求路由给最相似的节点，也就是从之前的请求结果中进行学习（？不太明白如何做的）
2. Iterative Deepening
  * 只针对于只需要一个或很少几个请求结果就可以的情况，算法也很简单，对ttl从1到最大值进行遍历，每次遍历就是进行一次标准的bfs，如果该次遍历返回一个或多个结果就停止遍历，返回请求结果，再次注意，这种算法只是针对那些只要一个或很少几个结果就可以的情况。
3. Random Walks
  * 类似随机化的BFS，每个随机性地抽取相邻节点进行转发，直至达到routing message的ttl过期。有研究表明这种算法比标准的bfs所需要的routing message少很多，但是算法不稳定，随着拓扑结构等波动很大。
4. Adaptive Probabilistic Search
  * 类似智能化BFS，在一开始每个节点的相邻节点的概率值相等，在路由过程中成功或者失败都会增加或者减少概率值（乐观和悲观两种），这样之后的请求就能利用之前请求的成功和失败的经验来指导其路由路径的选择。但是由于p2p节点的自由性，网络的拓扑结构会随着时间发生很大改变（旧节点退出，新节点加入），这种智能化搜索带来的优势就会减少。
5. Local Indices
  * 本地化索引策略还是很有意思的，每一个节点以自己为圆心，指定ttl为半径，建立数据索引，在建立索引过程中还是使用bfs搜索，但是由于每一个节点都有一个圆内所有数据的索引，那么在一个新的请求发送过程中，就不需要一个一个遍历节点，而是采用2r+1为遍历距离（前一个节点为1的话，遍历后一个节点为2r+2），这样就能减少请求的处理负担，提高网络的可扩展性。但是还是由于节点的自由性，加入离开网络或者更改数据都会有更新索引的overhead，所以对高度动态化的p2p不合适。
6. Bloom Filter based Indices
  * 使用布隆过滤器来索引数据，每一个节点拥有的n（相邻节点个数）*d个布隆过滤器，每个相邻节点的第i个过滤器代表i个hop distance之外的索引，那么在询问当前节点时就可以继续转发至拥有最小数字的布隆过滤器（最近hop distance）的相邻节点。使用布隆过滤器可以带来更低的空间成本，但是有时候会产生false positive的结果。
7. Distributed Resource Location Protocol
  * 每一个节点建立之前请求转发成功的节点位置的索引，那么后续的节点就可以利用这一索引信息快速地定位请求的数据所在的节点位置。这种算法在初期可能比较费时，但是只要能被之后的索引命中，那么就能一步抵达后续节点。这在一些频繁的重复请求中比较适用。
  * 建立的过程还是请求成功之后沿着路径反向传播一次，依次建立索引。

#### 结构化虚拟网络（DHT）
这里有一个专业名词叫 routing geometry，DHT用此来安排节点和路由请求。
1. Tree
  * 每一个节点构成树形结构的叶子节点，每一个叶子节点再维护一个路由表，每一个路由表中至少需要记录log(n)个节点，这log(n)个节点会和该叶子节点有从0到log(n)的prefix重叠，（举例比如100节点的路由表可以有101，111， 010这三个节点，101与100有两位高位重叠，111有一位重叠，010有零位重叠）每次处理一个请求，会比较请求的数据的key与路由表中节点的prefix，转发至与key最多重叠的节点进行后续处理，不断转发直至重叠达到最大，那么最终时间复杂度为log(n)。很漂亮的算法。
2. Hypercube
  * 超方形的routing geometry和树形类似，都是基于bit的不同来进行路由转发，不过Hypercube不需要从高位到低位，而是任意位有相同/差异来进行后续转发，直到转发到与key有最多重叠的节点即可。CAN就是采用这一策略。
3. Ring
  * 环状的结构会对节点的identifier进行排序，每个节点的路由表其顺时针2i距离的节点，如果已知请求数据的key，那么就可以利用顺时针2^i距离的路由表来跳转到最近的节点来进行后续的跳转。
4. Butterfly
  * 蝴蝶状的结构将所有节点分成log(n)的level和n/log(n)的行，每一个节点只需要储存常数级的邻接节点信息即可，而上述三种需要对数级的邻接节点信息，但是这种结构的节点跳转是需要严格遵循规则来进行的，因为每个节点对网络的消息知之甚少，遵循规则才能保证能找到最终节点。（规则就是先在同一行内跳跃找到level1，再从level1跳跃找到最终节点所在行，在最终的那一行找到最终节点//每一行内是依次连接，不同行是通过level的不同来跳转跨行连接）
5. Hybrid
  * 举例来说，Pastry使用了树状和环状杂化的结构，既维护一个树，又维护一个环，那么在跳转节点的选择就会很灵活，相当于多了一种选择方案。

#### Super-peer
1. 超级节点之间的路由还是采用以上的算法/结构的某一种，但是超级节点和普通节点的路由是有超级节点内的索引提供。
2. 超级节点内维护着两套索引，一套是超级索引/超级索引，另一套是超级/普通索引，本质上讲，超级索引/超级索引是对超级/普通索引的总结，每当超级/普通索引发生改变时，就会通过广播邻接节点来改变路由表中存在的超级超级索引，由于超级节点数目较少，通过广播开销也不大，也可以通过定时批量广播来降低开销。

### Gossip protocol闲话协议
to be continued。。。