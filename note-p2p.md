# P2P Techniques for Decentralized Application学习笔记
## preface
1. p2p的优势在于去中心化与对称性（自己既是服务端又是客户端）带来的自我扩展性（self-scalability），自组织性（self-organization），容错性（fault-tolerance）。
2. p2p比较难实现针对关键词的推荐搜索，top-k可以避免搜索过多无用的信息来阻塞p2p的网络，这本书主要关注于p2p在top-k，CDN与推荐系统上的应用。

## 第一章 P2P Overlays ,Query Routing, and Gossiping
### P2P与传统的分布式数据库系统的区别
1. P2P网络中的节点非常动态，可以在任意时间自由进入和离开网络中，而分布式数据库系统中的节点则是需要被控制的情况下才能进入和离开。
2. p2p没有事先定义的全局性的schema来描述需要被节点分享的数据。
3. p2p系统中对请求的响应是不完全的，因为有一些节点在请求发出时不在网络中，对于非常大的p2p网络，把请求转发给所有节点是非常没有效率的。
4. p2p系统中没有集中式的目录来决定请求的内容位于哪些节点中，与之对比的是，这样的集中式目录对于分布式数据库系统是非常必要的。

### P2P overlays
+ p2p的虚拟网络的架构有三种，无结构式，结构式和super-peer式。

1. 无结构式
  * 在一个无结构的p2p虚拟网络中，网络的拓扑结构处于无序状态，请求的路由策略就是限制请求源的跳跃距离（hop distance）。
  * 在这种情况下，请求的形式没有限制，容错率非常高，每一个节点可以自主地决定储存哪些数据。
  * 但是这种架构，请求路由没有效率（网络的负载很高，一定程度上牺牲了可扩展性），同时请求地结果很有可能不完全（一些拥有相关数据的节点超过了规定的hop distance）。
2. 结构式
  * 结构式的虚拟网络主要在于能够**有效率**地进行请求的路由，主要代表是分布式hash表（DHT），hash表通过通过建立数据的hash值和节点p的映射，可以让寻找节点p的时间复杂度控制在O(logn)，n是网络中节点的个数。DHT如同普通的hash表一样提供get和put方法。
  * 采用这种架构的虚拟网络的节点的自由度受到了限制，因为特定数据的hash值映射得到的节点p是需要被用来提供该特定数据的。
3. super-peer
  * super-peer是对纯p2p架构（以上所述的两种）和cs架构（client-server架构）的混合，在这种虚拟网络结构中有一些超级节点（被称作super peer）需要进行例如索引，请求处理，权限控制以及元数据管理的工作，（如果只有一个超级节点，那么这种架构就会退化成传统的cs架构），这些超级节点之间可以使用p2p来进行连接和通信，所以可以实现一些数据的分区和重复，当然这些特殊节点是通过他们的带宽和处理能力来动态地选举产生以及被替换的。
  * 在响应请求时，超级节点可以从自身的索引（询问自身节点群？）来直接响应或者询问相邻的超级节点来响应，这种架构的主要优点是服务的高效率和高质量，通过索引来获取数据的响应的时间远低于无规则的路由响应时间，超级节点由于是动态选举出来的，他需要负载压力时大于自身节点群中的普通节点的，但是不同于cs架构，超级节点也是可以利用其他普通节点的cpu/储存/贷款等能力来提供服务，而不是全部自身来响应。这种架构下普通节点的自治能力需要被限制，不能随意跨越超级节点。

p2p虚拟网络的几个要求
1. *自治性* 可以在任何时间加入和离开系统以及可以被任何人连接
2. *请求的可表达性* 对于文件类的p2p关键字搜索就足够了，但是对于一些结构化数据，需要使用一些类似于sql的请求语言。
3. *请求的有效处理* 高效利用p2p的网络资源可以达到较低的延时。
4. *服务质量* 指的是用户接受到的p2p效率，包括请求结果的完全性以及响应时间
5. *容错性* 服务需要保证在一些节点崩溃的情况下仍然正常工作。

### Query Routing请求路由算法概述
#### 无结构虚拟网络请求路由算法
1. BFS搜索
  * 在特定的ttl下，转发请求，每转发一次ttl减少1，直至ttl降低为0，这样就会使得在hop distance小于ttl的节点收到并处理请求。
  * 对BFS搜索进行一定的修改，例如随机地搜索一部分邻居节点（而不是像bfs一样全局搜）或者是维护一个请求相似性统计数据，优先把请求路由给最相似的节点，也就是从之前的请求结果中进行学习（？不太明白如何做的）
2. Iterative Deepening
  * 只针对于只需要一个或很少几个请求结果就可以的情况，算法也很简单，对ttl从1到最大值进行遍历，每次遍历就是进行一次标准的bfs，如果该次遍历返回一个或多个结果就停止遍历，返回请求结果，再次注意，这种算法只是针对那些只要一个或很少几个结果就可以的情况。
3. Random Walks
  * 类似随机化的BFS，每个随机性地抽取相邻节点进行转发，直至达到routing message的ttl过期。有研究表明这种算法比标准的bfs所需要的routing message少很多，但是算法不稳定，随着拓扑结构等波动很大。
4. Adaptive Probabilistic Search
  * 类似智能化BFS，在一开始每个节点的相邻节点的概率值相等，在路由过程中成功或者失败都会增加或者减少概率值（乐观和悲观两种），这样之后的请求就能利用之前请求的成功和失败的经验来指导其路由路径的选择。但是由于p2p节点的自由性，网络的拓扑结构会随着时间发生很大改变（旧节点退出，新节点加入），这种智能化搜索带来的优势就会减少。
5. Local Indices
  * 本地化索引策略还是很有意思的，每一个节点以自己为圆心，指定ttl为半径，建立数据索引，在建立索引过程中还是使用bfs搜索，但是由于每一个节点都有一个圆内所有数据的索引，那么在一个新的请求发送过程中，就不需要一个一个遍历节点，而是采用2r+1为遍历距离（前一个节点为1的话，遍历后一个节点为2r+2），这样就能减少请求的处理负担，提高网络的可扩展性。但是还是由于节点的自由性，加入离开网络或者更改数据都会有更新索引的overhead，所以对高度动态化的p2p不合适。
6. Bloom Filter based Indices
  * 使用布隆过滤器来索引数据，每一个节点拥有的n（相邻节点个数）*d个布隆过滤器，每个相邻节点的第i个过滤器代表i个hop distance之外的索引，那么在询问当前节点时就可以继续转发至拥有最小数字的布隆过滤器（最近hop distance）的相邻节点。使用布隆过滤器可以带来更低的空间成本，但是有时候会产生false positive的结果。
7. Distributed Resource Location Protocol
  * 每一个节点建立之前请求转发成功的节点位置的索引，那么后续的节点就可以利用这一索引信息快速地定位请求的数据所在的节点位置。这种算法在初期可能比较费时，但是只要能被之后的索引命中，那么就能一步抵达后续节点。这在一些频繁的重复请求中比较适用。
  * 建立的过程还是请求成功之后沿着路径反向传播一次，依次建立索引。

#### 结构化虚拟网络（DHT）
这里有一个专业名词叫 routing geometry，DHT用此来安排节点和路由请求。
1. Tree
  * 每一个节点构成树形结构的叶子节点，每一个叶子节点再维护一个路由表，每一个路由表中至少需要记录log(n)个节点，这log(n)个节点会和该叶子节点有从0到log(n)的prefix重叠，（举例比如100节点的路由表可以有101，111， 010这三个节点，101与100有两位高位重叠，111有一位重叠，010有零位重叠）每次处理一个请求，会比较请求的数据的key与路由表中节点的prefix，转发至与key最多重叠的节点进行后续处理，不断转发直至重叠达到最大，那么最终时间复杂度为log(n)。很漂亮的算法。
2. Hypercube
  * 超方形的routing geometry和树形类似，都是基于bit的不同来进行路由转发，不过Hypercube不需要从高位到低位，而是任意位有相同/差异来进行后续转发，直到转发到与key有最多重叠的节点即可。CAN就是采用这一策略。
3. Ring
  * 环状的结构会对节点的identifier进行排序，每个节点的路由表其顺时针2<sup>i</sup>距离的节点，如果已知请求数据的key，那么就可以利用顺时针2^i距离的路由表来跳转到最近的节点来进行后续的跳转。
4. Butterfly
  * 蝴蝶状的结构将所有节点分成log(n)的level和n/log(n)的行，每一个节点只需要储存常数级的邻接节点信息即可，而上述三种需要对数级的邻接节点信息，但是这种结构的节点跳转是需要严格遵循规则来进行的，因为每个节点对网络的消息知之甚少，遵循规则才能保证能找到最终节点。（规则就是先在同一行内跳跃找到level1，再从level1跳跃找到最终节点所在行，在最终的那一行找到最终节点//每一行内是依次连接，不同行是通过level的不同来跳转跨行连接）
5. Hybrid
  * 举例来说，Pastry使用了树状和环状杂化的结构，既维护一个树，又维护一个环，那么在跳转节点的选择就会很灵活，相当于多了一种选择方案。

#### Super-peer
1. 超级节点之间的路由还是采用以上的算法/结构的某一种，但是超级节点和普通节点的路由是有超级节点内的索引提供。
2. 超级节点内维护着两套索引，一套是超级索引/超级索引，另一套是超级/普通索引，本质上讲，超级索引/超级索引是对超级/普通索引的总结，每当超级/普通索引发生改变时，就会通过广播邻接节点来改变路由表中存在的超级超级索引，由于超级节点数目较少，通过广播开销也不大，也可以通过定时批量广播来降低开销。

### Gossip protocol闲话协议
1.  闲话协议非常容易实现，而且被广泛地用来进行p2p系统内地消息传播。非常适用于大规模的动态系统。
2. 在进行协议通信的过程中，可以分为主动节点和被动节点，主动节点是用来推送消息（push），被动节点是用来索取消息（pull），也可以两者同时存在。
3. 闲话协议主要是用来进行消息传播，资源监控，拓扑构建以及节点采样。
4. 闲话算法的优势在于简单容易实现，每一个节点都可以进行自己的决策，给与相当大的自由度，通过节点间随机的重复交换信息，整体系统就能有良好的鲁棒性。但是缺点是运行时间比较慢，背景信息比较多，需要不断进行调参来符合特定应用的要求。
5. 总得来说，p2p系统在虚拟网络层和搜索层都可以利用闲话协议。在虚拟网络层，利用闲话协议可以进行节点采样（通过随机交换其路由表（view信息）来更新或者发现新节点）来构建拓扑结构；在搜索层可以通过消息的传播来共享索引信息。这里看的云里雾里，和之前一部分的query routing有点矛盾的感觉。前面的一些算法要求的是储存特定的路由信息达到较低的时间复杂度，而这里又完全随机来不断交换view信息。之后实践时需要复习这一块内容。

### Replication重复
1. 数据重复通常被用来提高可用性和系统的整体性能，当一个节点不可用时，节点中包含的数据仍然可以从其他节点中得到，总体可以分为以下两类：
  * _被动重复_ 这一种方式是较为自然的，当节点请求并下载数据后，该节点就成为了重复节点，该种方式使得整个系统的重复鲁棒性完全依赖于节点的自治。
  * _主动重复_ 这种方式通过监控网络流量和请求，创建重复数据对象以满足未来的请求需求。
2. DHT类型结构化虚拟网络的数据重复主要也有两种，一种是使用不同的hash函数对同一对象创建不同的key来储存在DHT中，那么DHT就会将同一对象储存在不同节点。另外一种是对象的key来匹配不同节点的id，匹配性就是key和id有多重复，重复性最高的一组节点来储存该对象来实现对象储存的同步。
3. 在非结构化虚拟网络中，数据重复主要有三种：但是书中提到了不知如何去中心化地实现（基于概率的？）主动重复的策略，同时也会让一些没有请求过特定数据的节点被迫储存该数据，损害节点的自主性。
  * *统一策略* 对象一进入p2p系统之后就立即创建固定数目的拷贝
  * *正比策略* 对象每次被请求就会创建一定数目的拷贝，请求次数越多，拷贝数目也就越多。
  * *平方根重复策略* 与上一个几乎一样，就是拷贝的数目正比于请求频率的平方根次幂。


## P2P虚拟网络的高级（复杂）特性
### locality-awareness overlays
* 该种虚拟网络主要是考虑到两个逻辑位置较远的节点可能位于物理位置很近的网络内，这样这两个节点通讯就会兜一个大圈，对底层网络资源产生不必要的损耗，所以将物理位置（实际网络中的距离）纳入虚拟网络建设的指标很有必要。书中提到，p2p带来的网络带宽的占用是主要的网络资源消耗者。有以下几种方式能实现locality-awareness的优化：
1. 集群 Clustering 集群将物理位置相近的节点组合成一个集群，集群内部有一个中心化的服务器来确定集群内的路由，这种方式有点像是super-peer方案。
2. LTM技术 节点通过发送一个detector来发现相近的节点，通过添加物理位置近的节点为邻接节点和删去效率低的邻接节点，可以实现网络结构的优化，但是这种方式随着时间的延长，对长时间运行的系统的优化程度会减少。
3. Locality-Aware structured overlays 传统意义上的结构化虚拟网络并未将local-awareness纳入构建虚拟网络的考量，现阶段的结构化虚拟网络就将解决物理位置作为首要任务，主要有以下三种手段：
  * Geographic Layout 节点的id的给与是根据物理网络的相近性来判断的，相近的节点id具有相近的物理位置。
  * Proximity routing 路由表的建立还是不考虑位置特性，但是在路由算法的选择上，选择路由表中物理距离最近的节点。
  * Proximity neighbor selection 路由表的建立就考虑位置特性，当几个候选节点都能成为路由表中的一个节点时，优先考虑物理位置近的节点。
  * 所谓**物理节点相近**是指round-trip-time的大小。但是动态节点之间rtt的维护成本还是比较高的，所以有人又想出了放置各种地标，节点与不同地标中的rtt就会产生一个延时排序，延时排序相同的节点更有可能物理位置相近，所以就可以将节点分成不同组，每一组内的延时排序相等。这种算法简单且容易实现。

### interest-based overlays
* 这种虚拟网络建立在如下的假设：如果一个节点拥有我感兴趣的一样东西，那么非常有可能这个节点还有我感兴趣的其他东西。那么节点之间的semantic proximity就可以通过兴趣的相似度来表示，通过利用这些内在的相似性，在使用内容分发和推荐算法上能得到很大的提高，之后第二和第三章会详细地进行解释。

#### p2p overlay combination
* 通过结合结构化和非结构化虚拟网络（或者考虑物理位置相近和兴趣相似的虚拟网络），这样的虚拟网络就可以实现博采众长，找到更适合应用特点的虚拟网络。
* 书中举了一些例子例如往非结构化的网络加入一些结构化的节点（难以想象如何实现）试图解决消息重复性和节点灵活性-复杂请求支持之间的矛盾；同一个节点同时维护两套邻接节点，一套是物理位置相近性，一套是兴趣相似性，这样就能利用两个虚拟网络的优势；同一个节点既是结构化节点，又是非结构化节点，也就是整个系统可以随着应用的不同改变虚拟网络的架构。
* 多层结构化虚拟网络来实现对不同带宽和能力的节点进行分层处理，又有点super-peer的味道在里面。

#### 第一章小结  
* 结构化网络有较低的请求表达性，非结构化网络处理请求比较没有效率，super-peer容错率比较低。
* 我自身作为初学者阅读下来的感受是可以看懂但是难以想到具体的代码实现，像是一个综述不像是一个好的教科书。但是还是对作者致以崇高敬意。

## 第二章 Content Distribution in P2P Systems
### 概述
CDN可以提高客户端的服务质量，降低时延，同时可以降低原服务端的负载和带宽需求。CDN采用p2p架构会比较便宜和具有扩展性，但是设计出一个可以利用p2p自我扩展性的p2p系统是非常具有挑战性的。

### 传统CDN介绍
代理可以分为转发代理和反向代理。转发代理就类似于VPN，把所有请求发送给VPN，VPN再代为发送请求，反向代理是相当于一个代理服务器，将一些静态文件可以代为回复。CDN一般可以认为是反向代理，通过在全球部署数百个服务器来实现静态文件内容的缓存和转发。CDN要求三个特性：可依靠性（鲁棒性），性能（低延时），可扩展性。

### p2p内容分发
现在大多数的p2p系统都术语内容分发的类别中，通过p2p内容节点的共同合作，共享资源，可以就代替需要使用高性能服务器的需求。
* p2p虚拟网络的一些高级特性能帮助p2p性能的提升，但是也需要一点这些高级特性带来的overhead与实际性能的提升需要进行权衡。CDN的p2p系统需要考虑物理位置（locality awareness），而且是首先需要考虑的因素，因为较近的物理位置能快速地响应用户请求。但是需要考虑的是如何简单且可接受地维护一个p2p系统来适应节点动态性和大规模特性。
* 通常来讲，大多数p2p应用会牺牲节点地自治性来达到更高效地进行内容分发。但是如果使用了兴趣相近（interest awareness）地原则来智能化地搭建虚拟网络，就可以给与节点一定地自治权力（用户节点只保存他请求地内容，而不保存一些本身不敢兴趣地内容），从而也提到了内容搜索地效率。但是系统需要监测节点兴趣发生改变地过程，需要动态地适应内部节点而改变自己地拓扑结构。
* 结构化地虚拟网络和非结构化虚拟网络的结合对于CDN来说也是很有意思但有挑战性的，有一个想法就是可以使用一种overlay来对另一种overlay来进行维护。

#### p2p CDN解决方案
* 书中主要使用了CoralCDN作为案例来详细介绍。to be continued。。。
